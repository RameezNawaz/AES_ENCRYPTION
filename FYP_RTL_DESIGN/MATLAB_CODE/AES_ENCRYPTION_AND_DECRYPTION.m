sbox = [0x63 0x7C 0x77 0x7B 0xF2 0x6B 0x6F 0xC5 0x30 0x01 0x67 0x2B 0xFE 0xD7 0xAB 0x76;
        0xCA 0x82 0xC9 0x7D 0xFA 0x59 0x47 0xF0 0xAD 0xD4 0xA2 0xAF 0x9C 0xA4 0x72 0xC0;
        0xB7 0xFD 0x93 0x26 0x36 0x3F 0xF7 0xCC 0x34 0xA5 0xE5 0xF1 0x71 0xD8 0x31 0x15;
        0x04 0xC7 0x23 0xC3 0x18 0x96 0x05 0x9A 0x07 0x12 0x80 0xE2 0xEB 0x27 0xB2 0x75;
        0x09 0x83 0x2C 0x1A 0x1B 0x6E 0x5A 0xA0 0x52 0x3B 0xD6 0xB3 0x29 0xE3 0x2F 0x84;
        0x53 0xD1 0x00 0xED 0x20 0xFC 0xB1 0x5B 0x6A 0xCB 0xBE 0x39 0x4A 0x4C 0x58 0xCF;
        0xD0 0xEF 0xAA 0xFB 0x43 0x4D 0x33 0x85 0x45 0xF9 0x02 0x7F 0x50 0x3C 0x9F 0xA8;
        0x51 0xA3 0x40 0x8F 0x92 0x9D 0x38 0xF5 0xBC 0xB6 0xDA 0x21 0x10 0xFF 0xF3 0xD2;
        0xCD 0x0C 0x13 0xEC 0x5F 0x97 0x44 0x17 0xC4 0xA7 0x7E 0x3D 0x64 0x5D 0x19 0x73;
        0x60 0x81 0x4F 0xDC 0x22 0x2A 0x90 0x88 0x46 0xEE 0xB8 0x14 0xDE 0x5E 0x0B 0xDB;
        0xE0 0x32 0x3A 0x0A 0x49 0x06 0x24 0x5C 0xC2 0xD3 0xAC 0x62 0x91 0x95 0xE4 0x79;
        0xE7 0xC8 0x37 0x6D 0x8D 0xD5 0x4E 0xA9 0x6C 0x56 0xF4 0xEA 0x65 0x7A 0xAE 0x08;
        0xBA 0x78 0x25 0x2E 0x1C 0xA6 0xB4 0xC6 0xE8 0xDD 0x74 0x1F 0x4B 0xBD 0x8B 0x8A;
        0x70 0x3E 0xB5 0x66 0x48 0x03 0xF6 0x0E 0x61 0x35 0x57 0xB9 0x86 0xC1 0x1D 0x9E;
        0xE1 0xF8 0x98 0x11 0x69 0xD9 0x8E 0x94 0x9B 0x1E 0x87 0xE9 0xCE 0x55 0x28 0xDF;
        0x8C 0xA1 0x89 0x0D 0xBF 0xE6 0x42 0x68 0x41 0x99 0x2D 0x0F 0xB0 0x54 0xBB 0x16];
    
    
isbox = [
    0x52  0x09  0x6A  0xD5  0x30  0x36  0xA5  0x38  0xBF  0x40  0xA3  0x9E  0x81  0xF3  0xD7  0xFB;
    0x7C  0xE3  0x39  0x82  0x9B  0x2F  0xFF  0x87  0x34  0x8E  0x43  0x44  0xC4  0xDE  0xE9  0xCB;
    0x54  0x7B  0x94  0x32  0xA6  0xC2  0x23  0x3D  0xEE  0x4C  0x95  0x0B  0x42  0xFA  0xC3  0x4E;
    0x08  0x2E  0xA1  0x66  0x28  0xD9  0x24  0xB2  0x76  0x5B  0xA2  0x49  0x6D  0x8B  0xD1  0x25;
    0x72  0xF8  0xF6  0x64  0x86  0x68  0x98  0x16  0xD4  0xA4  0x5C  0xCC  0x5D  0x65  0xB6  0x92;
    0x6C  0x70  0x48  0x50  0xFD  0xED  0xB9  0xDA  0x5E  0x15  0x46  0x57  0xA7  0x8D  0x9D  0x84;
    0x90  0xD8  0xAB  0x00  0x8C  0xBC  0xD3  0x0A  0xF7  0xE4  0x58  0x05  0xB8  0xB3  0x45  0x06;
    0xD0  0x2C  0x1E  0x8F  0xCA  0x3F  0x0F  0x02  0xC1  0xAF  0xBD  0x03  0x01  0x13  0x8A  0x6B;
    0x3A  0x91  0x11  0x41  0x4F  0x67  0xDC  0xEA  0x97  0xF2  0xCF  0xCE  0xF0  0xB4  0xE6  0x73;
    0x96  0xAC  0x74  0x22  0xE7  0xAD  0x35  0x85  0xE2  0xF9  0x37  0xE8  0x1C  0x75  0xDF  0x6E;
    0x47  0xF1  0x1A  0x71  0x1D  0x29  0xC5  0x89  0x6F  0xB7  0x62  0x0E  0xAA  0x18  0xBE  0x1B;
    0xFC  0x56  0x3E  0x4B  0xC6  0xD2  0x79  0x20  0x9A  0xDB  0xC0  0xFE  0x78  0xCD  0x5A  0xF4;
    0x1F  0xDD  0xA8  0x33  0x88  0x07  0xC7  0x31  0xB1  0x12  0x10  0x59  0x27  0x80  0xEC  0x5F;
    0x60  0x51  0x7F  0xA9  0x19  0xB5  0x4A  0x0D  0x2D  0xE5  0x7A  0x9F  0x93  0xC9  0x9C  0xEF;
    0xA0  0xE0  0x3B  0x4D  0xAE  0x2A  0xF5  0xB0  0xC8  0xEB  0xBB  0x3C  0x83  0x53  0x99  0x61;
    0x17  0x2B  0x04  0x7E  0xBA  0x77  0xD6  0x26  0xE1  0x69  0x14  0x63  0x55  0x21  0x0C  0x7D
];


const_mat = [0x02 0x03 0x01 0x01;
             0x01 0x02 0x03 0x01;
             0x01 0x01 0x02 0x03;
             0x03 0x01 0x01 0x02]; 
         
 inv_const_mat = [0x0e 0x0b 0x0d 0x09;
                 0x09 0x0e 0x0b 0x0d;
                 0x0d 0x09 0x0e 0x0b;
                  0x0b 0x0d 0x09 0x0e];

cipher_key = [0x01 0x02 0x03 0x04;
              0x05 0x06 0x07 0x08;
              0x09 0x0A 0x0B 0x0C;
              0x0D 0x0E 0x0F 0x10];

plain_text = [0x01 0x02 0x04 0x03;
              0x02 0x03 0x02 0x01;
              0x04 0x05 0x06 0x07;
              0x07 0x05 0x04 0x03];

% Key expansion
expanded_key = key_expansion(cipher_key);
disp('Expanded Key:');
disp(expanded_key);

disp('Plain Text:');
disp(plain_text);

%****************************************
%ENCRYPTION
%****************************************

% Initial AddRoundKey
temp = bitxor(plain_text, cipher_key');
disp('After Initial AddRoundKey:');
disp(temp);

% Perform 10 rounds
for i = 1:10
    temp = sub_byte(temp, sbox);  % SubBytes
    disp(['After SubBytes, Round ', num2str(i), ':']);
    disp(temp);
    
    temp = shift_rows(temp);  % ShiftRows
    disp(['After ShiftRows, Round ', num2str(i), ':']);
    disp(temp);
    
    if i <= 9
        temp = mix_columns(const_mat, temp);  % MixColumns (skip on last round)
        disp(['After MixColumns, Round ', num2str(i), ':']);
        disp(temp);
    end
    
    temp = add_round_key(temp, expanded_key, i);  % AddRoundKey
    disp(['After AddRoundKey, Round ', num2str(i), ':']);
    disp(temp);
end

disp('Cipher Text:');
cipher_text=temp;
disp(cipher_text);

%****************************************
%DECRYPTION
%****************************************

temp2 = bitxor(cipher_text, expanded_key(:,41:44));
disp('After Initial inv_AddRoundKey:');
disp(temp2);

% Perform 10 rounds
for j = 1:10
    
    temp2 = inv_shift_rows(temp2);  % ShiftRows
    disp(['After inv_ShiftRows, Round ', num2str(11-j), ':']);
    disp(temp2);
    

    temp2 = inv_sub_byte(temp2, isbox);  % SubBytes
    disp(['After inv_SubBytes, Round ', num2str(11-j), ':']);
    disp(temp2);
    
     temp2 =inv_add_round_key(temp2, expanded_key, 11-j);  % AddRoundKey
    disp(['After inv_AddRoundKey, Round ', num2str(11-j), ':']);
    disp(temp2);
    
    if 11-j > 1
        temp2 = inv_mix_columns(inv_const_mat, temp2);  % MixColumns (skip on last round)
        disp(['After inv_MixColumns, Round ', num2str(11-j), ':']);
        disp(temp2);
    end
end
disp('decrypted Text:');
decrypted_text=temp2;
disp(decrypted_text);


%****************************************
% Functions for decryption
%****************************************

function out=inv_shift_rows(in)
out=zeros(4,4);
        out(1,:)=[in(1,1) in(1,2) in(1,3) in(1,4)];
        out(2,:)=[in(2,4) in(2,1) in(2,2) in(2,3)];
        out(3,:)=[in(3,3) in(3,4) in(3,1) in(3,2)];
        out(4,:)=[in(4,2) in(4,3) in(4,4) in(4,1)];       
end


function out = inv_sub_byte(in, isbox)
    out = zeros(4, 4);  % Initialize output matrix
    for j = 1:4
        for i = 1:4
            byte = in(i,j);  % Get byte value
            row = bitshift(byte, -4);  % First nibble (high 4 bits)
            col = bitand(byte, 15);  % Second nibble (low 4 bits)
            out(i, j) = isbox(row + 1, col + 1);  % Substitute using S-box
        end
    end
end

function out =inv_add_round_key(in,key,round)
out=zeros(4,4);
    for j=1:4
      for i=1:4
    out(j,i)=bitxor(in(j,i),key(j,((round*4)-4)+i));
      end
    end
   end

%inv_mix_columns
function out = inv_mix_columns(inv_const_mat, in)
    
    out = zeros(size(in), 'uint8');
    for col = 1:size(in, 2)
        out(:, col) = gf_mult(inv_const_mat, in(:, col));
    end
end


%****************************************
% Functions for encryption
%****************************************
%subbyte
function out = sub_byte(in, sbox)
    out = zeros(4, 4);  % Initialize output matrix
    for j = 1:4
        for i = 1:4
            byte = in(i,j);  % Get byte value
            row = bitshift(byte, -4);  % First nibble (high 4 bits)
            col = bitand(byte, 15);  % Second nibble (low 4 bits)
            out(i, j) = sbox(row + 1, col + 1);  % Substitute using S-box
        end
    end
end

%shift_rows
function out=shift_rows(in)
out=zeros(4,4);
        out(1,:)=[in(1,1) in(1,2) in(1,3) in(1,4)];
        out(2,:)=[in(2,2) in(2,3) in(2,4) in(2,1)];
        out(3,:)=[in(3,3) in(3,4) in(3,1) in(3,2)];
        out(4,:)=[in(4,4) in(4,1) in(4,2) in(4,3)];       
end


%add_round_key
function out =add_round_key(in,key,round)
out=zeros(4,4);
    for j=1:4
      for i=1:4
    out(j,i)=bitxor(in(j,i),key(j,round*4+i));
      end
    end
end

%mix_column
function out = mix_columns(const_mat, in)
    out = zeros(size(in), 'uint8');
    for col = 1:size(in, 2)
        out(:, col) = gf_mult(const_mat, in(:, col));
    end
end


%****************************************
%function for galios field multiplication
%****************************************

function result = gf_mult(mat, vec)
    result = zeros(size(vec), 'uint8');
    for i = 1:4
        for j = 1:4
            result(i) = bitxor(result(i), gf_mul(mat(i, j), vec(j)));
        end
    end
end

function result = gf_mul(a, b)
    result = uint8(0);
    while b ~= 0
        if bitand(b, 1) ~= 0
            result = bitxor(result, a);
        end
        if bitand(a, 0x80) ~= 0
            a = bitshift(a, 1, 'uint8');
            a = bitxor(a, 0x1b);
        else
            a = bitshift(a, 1, 'uint8');
        end
        b = bitshift(b, -1, 'uint8');
    end
end


%**************************
%KEY_EXPANSION_FUNTION
%**************************
function expanded_key=key_expansion(cipher_key)
 
sbox =[99 124 119 123 242 107 111 197  48   1 103  43 254 215 171 118
        202 130 201 125 250  89  71 240 173 212 162 175 156 164 114 192
        183 253 147  38  54  63 247 204  52 165 229 241 113 216  49  21
          4 199  35 195  24 150   5 154   7  18 128 226 235  39 178 117
          9 131  44  26  27 110  90 160  82  59 214 179  41 227  47 132
         83 209   0 237  32 252 177  91 106 203 190  57  74  76  88 207
        208 239 170 251  67  77  51 133  69 249   2 127  80  60 159 168
         81 163  64 143 146 157  56 245 188 182 218  33  16 255 243 210
        205  12  19 236  95 151  68  23 196 167 126  61 100  93  25 115
         96 129  79 220  34  42 144 136  70 238 184  20 222  94  11 219
        224  50  58  10  73   6  36  92 194 211 172  98 145 149 228 121
        231 200  55 109 141 213  78 169 108  86 244 234 101 122 174   8
        186 120  37  46  28 166 180 198 232 221 116  31  75 189 139 138
        112  62 181 102  72   3 246  14  97  53  87 185 134 193  29 158
        225 248 152  17 105 217 142 148 155  30 135 233 206  85  40 223
        140 161 137  13 191 230  66 104  65 153  45  15 176  84 187  22];
    Rcon=[ 1 2 4 8 16 32 64 128 27 54;
           0 0 0 0 0 0 0 0 0 0  ;
           0 0 0 0 0 0 0 0 0 0  ;
           0 0 0 0 0 0 0 0 0 0  ; ];
          
    
    expanded_key=zeros(4,44);   
    for i=1:4
        expanded_key(:,i)=cipher_key(i,:);
    end 
    for i=4:43
        temp=expanded_key(:,i);
        if mod(i,4)== 0
            temp=rotate_word(temp);
            temp=substitute_word(temp,sbox);
            temp=bitxor(temp,Rcon(:,i/4));
        end
        expanded_key(:,i+1)=bitxor(temp,expanded_key(:,i-3));
    end
end

function out=rotate_word(in)
out=circshift(in,-1);
end

function out=substitute_word(in,sbox)
out =zeros(4,1);
for i=1:4
    byte=in(i);
    out(i)=sbox(byte+1);
end
end


